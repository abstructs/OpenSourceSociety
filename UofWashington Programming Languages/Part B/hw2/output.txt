ifaunit: first expression is aunit ('(ifaunit (fst (apair (aunit) (int 0))) (int 4) (int 10)) should result in MUPL that evaluates to (int 4) but resulted in (int 10)) [incorrect answer]
mlet*: sequential bindings (unbound variable during evaluation "x") [error]
mlet*: should not evaluate any MUPL or contain an explicit closure (eval-under-env used) [incorrect answer]
ifeq: resulting expression uses _x and _y variables (couldn't find binding of _x) [incorrect answer]
ifeq: resulting expression evaluates to e4 if e1 and e2 evaluate to non-equal integers (found bad MUPL expression: (ifeq (int 0) (int 1) (int 7) (add (int 9) (int 10)))) [error]
ifeq: resulting expression evaluates to e3 if e1 and e2 evaluate to equal integers (found bad MUPL expression: (ifeq (int 5) (int 5) (int 0) (int 1))) [error]
ifeq: resulting expression evaluates e1 and e2 exactly once (found bad MUPL expression: (ifeq (add (int 1) (int 2)) (add (int 55) (int 56)) (int 1) (int 2))) [error]
mupl-map: multiple element list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
mupl-map: single element list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
mupl-map: empty list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
mupl-mapAddN: multiple element list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
mupl-mapAddN: single element list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
mupl-mapAddN: empty list (found bad MUPL expression: (ifeq (int 1) (isaunit (var "lst")) (aunit) (apair (call (var "fun") (fst (var "lst"))) (call (var "aux") (snd (var "lst")))))) [error]
compute-free-vars: correctly computes free vars [incorrect answer]
compute-free-vars: no free vars case [incorrect answer]
eval-under-env-c: correctly filters closure environments [incorrect a
